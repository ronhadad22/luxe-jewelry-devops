@Library('shared-pipeline-library@main') _

pipeline {
    agent {
        kubernetes {
            yaml backendPipeline.getPodTemplate()
        }
    }
    
    environment {
        PYTHON_VERSION = '3.11'
        SERVICE_NAME = 'auth-service'
        AWS_DEFAULT_REGION = 'us-east-2'
        ECR_REGISTRY = '950555670656.dkr.ecr.us-east-2.amazonaws.com'
        ECR_REPOSITORY = 'jewleryapp/auth'
        IMAGE_TAG = "${BUILD_NUMBER}"
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Lint & Unit Tests') {
            when {
                expression {
                    BackendPipeline.isPullRequest(env) ||
                    BackendPipeline.isMainBranch(env) ||
                    (env.BRANCH_NAME ==~ /^feature\/.*/) ||
                    (env.BRANCH_NAME ==~ /^backend\/.*/) ||
                    (env.BRANCH_NAME ==~ /^patch\/.*/) ||
                    (env.BRANCH_NAME ==~ /^hotfix\/.*/) ||
                    (env.BRANCH_NAME ==~ /^release\/.*/) ||
                    (env.BRANCH_NAME ==~ /^develop(ment)?$/)
                }
            }
            steps {
                container('python') {
                    dir('auth-service') {
                        script {
                            BackendPipeline.setupPythonEnvironment(this)
                            BackendPipeline.runLinting(this)
                            BackendPipeline.runTests(this)
                    }
                }
            }
        }
            post {
                always {
                    dir('auth-service') {
                        junit testResults: 'test-results.xml', allowEmptyResults: false
                        publishHTML([
                            allowMissing: false,
                            alwaysLinkToLastBuild: true,
                            keepAll: true,
                            reportDir: 'htmlcov',
                            reportFiles: 'index.html',
                            reportName: 'Coverage Report'
                        ])
                    }
                }
            }
        }
        
        stage('Static Analysis') {
            when {
                expression {
                    BackendPipeline.isPullRequest(env) ||
                    BackendPipeline.isMainBranch(env) ||
                    (env.BRANCH_NAME ==~ /^feature\/.*/) ||
                    (env.BRANCH_NAME ==~ /^backend\/.*/) ||
                    (env.BRANCH_NAME ==~ /^patch\/.*/) ||
                    (env.BRANCH_NAME ==~ /^hotfix\/.*/) ||
                    (env.BRANCH_NAME ==~ /^release\/.*/) ||
                    (env.BRANCH_NAME ==~ /^develop(ment)?$/)
                }
            }
            steps {
                container('python') {
                    dir('auth-service') {
                        script {
                            BackendPipeline.runSecurityScans(this)
                        }
                    }
                }
            }
        }
        
        stage('PR Validation Image Build') {
            when {
                expression { BackendPipeline.isPullRequest(env) }
            }
            steps {
                container('docker-aws') {
                    dir('auth-service') {
                        script {
                            BackendPipeline.buildValidationImage(
                                this,
                                env,
                                env.ECR_REGISTRY,
                                env.ECR_REPOSITORY
                            )
                        }
                    }
                }
            }
        }
        
        stage('Determine Release Version') {
            when {
                expression { BackendPipeline.isMainBranch(env) }
            }
            steps {
                script {
                    def releaseVersion = BackendPipeline.determineReleaseVersion(this, env)
                    env.RELEASE_VERSION = releaseVersion
                    env.RELEASE_TAGS = [
                        "${releaseVersion}-dev",
                        "${releaseVersion}-rc",
                        releaseVersion
                    ].join(',')
                    echo "Release version determined: ${releaseVersion}"
                    echo "Release tags: ${env.RELEASE_TAGS}"
                }
            }
        }
        
        stage('Build Release Image') {
            when {
                expression { BackendPipeline.isMainBranch(env) }
            }
            steps {
                container('docker-aws') {
                    dir('auth-service') {
                        script {
                            def result = BackendPipeline.buildAndTagReleaseImage(
                                this,
                                env,
                                env.RELEASE_VERSION,
                                env.ECR_REGISTRY,
                                env.ECR_REPOSITORY
                            )
                            env.RELEASE_TEMP_TAG = result.tempTag
                            env.RELEASE_TAGS = result.releaseTags.join(',')
                        }
                    }
                }
            }
        }
        
        stage('Push Release Images') {
            when {
                expression { BackendPipeline.isMainBranch(env) }
            }
            steps {
                container('docker-aws') {
                    script {
                        def tags = env.RELEASE_TAGS?.split(',')?.collect { it.trim() }?.findAll { it }
                        BackendPipeline.pushTaggedImages(
                            this,
                            env.ECR_REGISTRY,
                            env.ECR_REPOSITORY,
                            tags,
                            env.AWS_DEFAULT_REGION
                        )
                    }
                }
            }
        }

        // TODO: GitOps manifest updates will be handled in a dedicated CD pipeline.
        // CI intentionally stops after publishing release images.
    }
    
    post {
        always {
            archiveArtifacts artifacts: 'auth-service/**/*-report.json, auth-service/**/*-results.xml, auth-service/**/htmlcov/**', allowEmptyArchive: true
            script {
                try {
                    deleteDir()
                } catch (Exception ex) {
                    echo "⚠️ Workspace cleanup skipped: ${ex.message}"
                }
            }
        }
        success {
            echo "✅ Auth Service CI pipeline completed successfully!"
        }
        failure {
            echo "❌ Auth Service CI pipeline failed!"
        }
    }
}
